// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types';


// âœ… Unified client using env vars
type EnvRecord = Record<string, string | undefined>;

const getBrowserInjectedEnv = (): EnvRecord => {
  if (typeof globalThis === 'undefined') {
    return {};
  }

  const globalObject = globalThis as Record<string, unknown>;
  const possibleEnvKeys = ['__ENV__', '__env__'];

  for (const key of possibleEnvKeys) {
    const value = Reflect.get(globalObject, key) as unknown;

    if (typeof value === 'object' && value !== null) {
      return value as EnvRecord;
    }
  }

  const maybeWindow = Reflect.get(globalObject, 'window') as unknown;

  if (typeof maybeWindow === 'object' && maybeWindow !== null) {
    for (const key of possibleEnvKeys) {
      const value = Reflect.get(
        maybeWindow as Record<string, unknown>,
        key,
      ) as unknown;

      if (typeof value === 'object' && value !== null) {
        return value as EnvRecord;
      }
    }
  }

  return {};
};

const getCloudflareContextEnv = (): EnvRecord => {
  if (typeof globalThis === 'undefined') {
    return {};
  }

  const globalObject = globalThis as Record<string, unknown>;
  const maybeContext = Reflect.get(globalObject, 'context') as unknown;

  if (typeof maybeContext === 'object' && maybeContext !== null) {
    const maybeEnv = Reflect.get(
      maybeContext as Record<string, unknown>,
      'env',
    ) as unknown;

    if (typeof maybeEnv === 'object' && maybeEnv !== null) {
      return maybeEnv as EnvRecord;
    }
  }

  return {};
};

const getImportMetaEnv = (): EnvRecord => {
  try {
    const meta = import.meta as ImportMeta & { env?: unknown };
    const maybeEnv = meta?.env;

    if (typeof maybeEnv === 'object' && maybeEnv !== null) {
      return maybeEnv as EnvRecord;
    }
  } catch (error) {
    // `import.meta` isn't available in all runtimes (for example, during SSR in
    // some worker environments). We intentionally swallow the error here and
    // fall back to other environment sources.
  }

  return {};
};

const getProcessEnv = (): EnvRecord => {
  if (typeof process === 'undefined') {
    return {};
  }

  try {
    return (process.env as EnvRecord) ?? {};
  } catch (error) {
    return {};
  }
};

const getEnvSources = (): EnvRecord[] => [
  getBrowserInjectedEnv(),
  getCloudflareContextEnv(),
  getImportMetaEnv(),
  getProcessEnv(),
];

const resolveEnvVar = (key: string): string => {
  const candidates: string[] = [key];

  if (!key.startsWith('VITE_')) {
    candidates.push(`VITE_${key}`);
  }

  if (key.startsWith('NEXT_PUBLIC_')) {
    const suffix = key.replace(/^NEXT_PUBLIC_/, '');
    candidates.push(suffix);
    candidates.push(`VITE_${suffix}`);
  }

  const envSources = getEnvSources();

  for (const candidate of candidates) {
    for (const source of envSources) {
      const value = source[candidate];

      if (typeof value === 'string' && value.length > 0) {
        return value;
      }
    }
  }

  throw new Error(`Environment variable "${key}" is not defined`);
};

const getAuthStorage = (): Storage | undefined => {
  if (typeof window === 'undefined') {
    return undefined;
  }

  try {
    return window.localStorage;
  } catch (error) {
    return undefined;
  }
};

const createSupabaseClient = (): SupabaseClient<Database> => {
  const url = resolveEnvVar('SUPABASE_URL');
  const anonKey = resolveEnvVar('SUPABASE_ANON_KEY');

  return createClient<Database>(url, anonKey, {
    auth: {
      storage: getAuthStorage(),
      persistSession: true,
      autoRefreshToken: true,
    },
  });
};

let cachedClient: SupabaseClient<Database> | null = null;

const getSupabaseClient = (): SupabaseClient<Database> => {
  if (!cachedClient) {
    cachedClient = createSupabaseClient();
  }

  return cachedClient;
};

const supabaseHandler: ProxyHandler<SupabaseClient<Database>> = {
  get(_target, prop, receiver) {
    const client = getSupabaseClient();
    const value = Reflect.get(client, prop, receiver);

    if (typeof value === 'function') {
      return value.bind(client);
    }

    return value;
  },
  set(_target, prop, value, receiver) {
    const client = getSupabaseClient();
    return Reflect.set(client, prop, value, receiver);
  },
  has(_target, prop) {
    return prop in getSupabaseClient();
  },
  ownKeys() {
    return Reflect.ownKeys(getSupabaseClient());
  },
  getOwnPropertyDescriptor(_target, prop) {
    const descriptor = Object.getOwnPropertyDescriptor(
      getSupabaseClient(),
      prop,
    );

    if (!descriptor) {
      return descriptor;
    }

    return {
      ...descriptor,
      configurable: true,
    } as PropertyDescriptor;
  },
  getPrototypeOf() {
    return Object.getPrototypeOf(getSupabaseClient());
  },
  defineProperty(_target, prop, attributes) {
    return Reflect.defineProperty(getSupabaseClient(), prop, attributes);
  },
  deleteProperty(_target, prop) {
    return Reflect.deleteProperty(getSupabaseClient(), prop);
  },
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = new Proxy(
  {} as SupabaseClient<Database>,
  supabaseHandler,
);
